### 1）JVM

 Java Virtual Machine java的虚拟运行环境，是支撑java跨平台运行语言特性的基础。JVM 封装了java语言与底层硬件系统和CPU交互的细节，使得使用java语言编译的字节码文件能够在任何安装了java虚拟机的平台上运行，即“一次编译，多处运行”。

 Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。
 ![img](\JVM.png)

### 2）NIO

NIO（non-blocking-IO）是同步非阻塞IO模型，也是IO多路复用模型。其核心组件包括channel（通道）、buffer(缓冲区）、selector(选择器）。标准IO是基于字节流和字符流进行操作的，而NIO是基于channel和buffer进行操作的，数据总是从通道读取到缓冲区或者从缓冲区写入到通道。一个选择器selector可以注册绑定多个channel通道，监听通道的到达、处理、连接打开等事件。selector会一直阻塞直到有注册的通道事件就绪。

channel 通道：全双工的数据传输通道，可以写入数据和可以从channel中读取数据，写入和读取数据需要通过缓冲区。

buffer 缓冲区：用于与channel进行交互，数据从通道读入缓冲区和从缓冲区写入通道。本质上是在内存上划分出一块区域被NIO包装成Buffer，并提供访问内存数据的方法。

selector 选择器：检测一个或N个通道，通过单线程处理多个channel的事件，线程阻塞直到有一个channel有事件就绪。

![img](\NIO.png)

### 3） 并发编程

基于CPU时间片的工作原理，应用程序能够通过多线程的方式提高CPU的使用效率。并发的基础概念在于系统资源不发生竞争的情况下多线程同时进行处理以提高系统的处理能力。总的来说并发的概念带来了提高资源利用率、 不同的用户和程序对于计算机上的资源使用的公平性以及通过多任务处理提高了任务处理的便利性。但是由于CPU资源的稀缺和JVM的内存模型设计导致了多线程在并发执行情况下的安全性大大降低，因此并发编程的一大挑战就是保证线程安全。为了保证线程安全jdk在设计过程中提供了一系列保证线程安全的方式，程序开发人员可灵活使用这些工具包来保证线程安全。
 ![img](\并发编程.png)

### 4）Spring 和 ORM 等框架

spring是一套为了简化java项目开发的轻量级框架，框架功能组件丰富。提供了DI、IOC、AOP等容器，提出了分层涉及的理念，包括表示层（controller)、业务层(service)、持久层(dao)。表示层由springMVC框架支撑，业务层核心是DI/IOC和AOP，持久层提供JDBC连接、ORM框架集成等。

ORM框架(object relation mapping)，提供了一套实体对象和关系数据库的映射关系。简化了持久层数据对象和底层关系数据库的映射，是的开发人员能够更加关注于业务逻辑和数据逻辑处理，淡化持久化操作（Sql）。Java中常见的ORM框架有：全自动的ORM框架hibernate(表和实体类的映射）、半自动的ORM框架mybatis（实体类和sql语句-xml描述文本的映射）。

![img](\Spring 和 ORM 等框架.png)

### 5）MySQL 数据库和 SQL

mysql 属于oracal旗下的一款关系型数据库管理系统，并且开源，使用者可以在源码基础上开发自己的功能插件。关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。mysql有sql接口、解析器、优化器、存储引擎、缓存等组成。掌握mysql需要清除了解几个方面：存储引擎、索引结构、复制备份、锁相关、事务相关、数据库性能。

**存储结构：**mysql提供了四个级别的数据存储。表空间->段->区-块（页）。

- innodb存储引擎中的数据是按照表空间存储的，表空间对应的着实际的物理存储。
- 段对应的是表，常见的有数据段、索引段、回滚段等。数据段就是页节点，索引段是非页节点。

- 区是一块连续的页，64个连续的页组成，每个页大小是16kB,也就是每个区大小是1M。
- 页/块：数据存储节点，每个页大小是16KB,存储表中的数据行。

**索引结构：**mysql提供两种索引结构哈希索引和B+树

- 哈希索引：使用哈希表存储索引的哈希值和行指针，单行查询效率显著提升。缺点是不能进行排序，另外容易出现哈希冲突（需进行遍历）。哈希索引一般适用于：不需要做**排序**、**范围查询的需求。**
- B+树索引**：**索引结构是B+树，叶节点存储数据（连续）、非页节点只存储索引+指针。根据页的大小16KB可知单页存储的键值个数为16*1024/(6+8)=1170个，所以两层索引树存储的行数据量为：1170^2*16 约为2千万。索引命中遵循最左原则，聚簇索引查询效率要比非聚簇索引高。

**复制备份：**mysql数据操作会产生binlog，数据备份和主从复制往往依赖于binlog同步。主从mysql实例会维持一个同步线程定时将binlog信息同步到从节点，从节点接收到信息后会依据binlog生成relaylog并开启线程将relaylog转换成sql语句刷盘。

**mysql锁：**mysq锁可以分为几个类型：行锁、间隙锁、临间锁。行锁锁定某行记录，间隙锁锁定一个范围内的记录行，临间锁是行锁和间隙锁的组合锁定索引行和前后的一个范围。按锁的粒度可以分为：表锁、页锁、行锁，表锁的范围最大，MySQL提供了锁升级的机制，特定场景下会进行锁升级。也分为排他锁和共享锁，共享锁即读锁相互之间兼容，排他锁也叫独占锁与其他排他锁和共享锁互斥，insert、update、delete默认添加排他锁。

mysql锁的原理本质上是对索引加锁，在不通过索引查询的时候锁的是整张表。

**mysql事务：**事务特性ACID（原子性、一致性、隔离性、持久性）。

mysql提供了四种隔离级别：读未提交、读已提交、可重复读（默认隔离级别）和串行化，隔离级别越高并行能力越弱。因为事的隔离性会造成数据的幻读、脏读和不可重复读。MySQL解决数据读取问题的方式是通过锁机制和多版本并发控制。通过加锁可以保证不出现脏读和幻读，而多版本维护了数据不同时间节点的快照，重复度的情况下保证每次读取初始版本，而读提交每次读取的是最新版本。

mysql提供的分布式事务解决方案：**XA（刚性事务）**，mysql内部不同存储引擎之间的事务联合使用时默认使用的就是XA。也支持不同数据库之间的刚性事务。XA提供的事务模型是，整个事务参与者分为了：资源管理器（mysql数据库本身）、事务管理器、应用程序，事务管理器一般由应用程序承担。XA的事务提交采用两段提交机制，第一段发起事务，第二阶段如果事务全部执行成功则进行提交、如果有一个执行失败则全部归滚。所以XA事务要么全部成功，要么全部失败，保证数据的强一致性。

目前分布式应用系统中更多用的是**TCC(柔性事务）**：有业务端来控制事务的提交回滚，保证数据的最终一致性。

TCC也保持两端提交的模式，与2PC不同的是，TCC事务控制是在业务端，而2PC控制是在资源管理。 TCC的核心思想是，try阶段检查并预留资源，确保在confirm阶段有资源可用，这样可以最大程度的确保confirm阶段能够执行成功。在try阶段保证一致性和隔离性，在confirm和cancel阶段保持幂等。

### ![img](\MySQL 数据库和 SQL.png)

### 7）RPC 和微服务

### 8）分布式缓存

分布式缓存是为了提高数据访问的效率，是对关系型数据库性能的补充。业务系统的复杂性以及信息化时代数据量的暴增和数据访问实时性的需求催生了非关系型数据存储的发展。非关系型数据库如Mongodb、redis、Hbase等补充了关系型数据库的不足，比如提供非关系性数据结构存储（K-V结构、列式存储、文件存储等）、高并发场景性读写能力强大、结构简单、操作方便。

**Redis数据结构：**Reids作为非关系性数据存储的一种，在高并发下的业务场景中使用较多。提供多种数据结构：String、List、set、zset(有序集合）、Hash（k-v结构）。

- String：操作get/set/incr/decr/mget等，普通的k-v操作都属于string类型。底层数据结构有多种： int（整型字符串），embstr(长度不超过44字节的短字符串）， raw（长字符串）。
- List：操作lpush/lpop/rpush/rpop/lrange/blpop(阻塞）可以实现栈、队列、消息队列等。维护的是一个双向链表。 可用来实现好友队列，粉丝队列，消息队列，最新消息排行等。底层数据结构使用的 压缩列表ziplist和普通的双向链表linkedlist和 快速列表组成。元素少的时候会用ziplist，元素多的时候会用linkedlist。

- Hash:操作hget/hset/hgetall，用来存储对象信息k-v格式，内部的数据结构是HashMap。用来存储对象信息。hash的底层数据结构 可以是ziplist也可以是我们的hashtable。
- set：操作sadd/spop/smembers，不重复的无序集合，内部也是HashMap，只用到了key。 集合有取交集、并集、差集等操作，因此可以求共同好友、共同兴趣、分类标签等。底层使用的是 hashtable和inset。

- zset：操作zadd，带有权重的有序集合（根据权重排序），可用来实现积分榜、点赞榜、排行榜单等。底层使用的是两种 一个ziplist，一个是skiplist。

**Redis特性：**内存性非关系型数据存储，数据可以持久化到文件中mdb，或操作命令持久化到文件aof。服务器宕机后重启时可通过持久化文件恢复数据以保证数据不丢失。提供缓存数据过期命令，可在设置缓存时指定失效时间，也可手动使缓存失效。默认缓存失效算法LRU，内存使用过高时最长未被使用的数据会被失效删除。

- Redis主从模式：一主多从，主写从读模式。主从同步分两步，从节点刚上线时与主节点建立连接后，主节点将全量数据复制一份通过异步sync传输给从节点，同时记录增量数据并进行第二次同步，之后的每个操作命令实时同步到从节点。
- Redis哨兵模式：核心还是主从，增加了哨兵节点用于在主节点宕机后能够通过自动选举出新的master节点，保证集群服务的高可用性。

- Redis Cluster模式：各节点均匀分配槽点。开启多主多从，主节点宕机后从节点继续使用。集群不可用的几种情况：若集群中有对主从节点同时宕机、一个主节点和所有从节点宕机、超过半数的主节点宕机。

分布式缓存常见问题：

**雪崩问题：**引发的原因在于缓存批量失效导致大量的请求直接触达数据库导致数据库压力飙升。解决方案：缓存失效时间设置成离散性避免同时失效；使用互斥锁，缓存失效时先获取锁再请求数据库，降低性能保证安全性；双缓存机制，一个会失效、一个永久，开启异步更新线程缓存的更新（两个缓存同时更新）。

**缓存击穿：**恶意攻击使得所有请求都不能命中缓存而触达数据库导致数据库压力飙升。解决方案：使用互斥锁，访问数据库之前需要先获得锁；使用异步更新机制，无论缓存key是否获取到值都直接返回，异步获取数据并进行更新；请求缓存的key拦截验证。

缓存并发竞争问题：同时多个请求设置缓存。解决方案：使用分布式锁；设置时间戳版本。

分布式缓存实现逻辑：setIfAbsent(setNX)+时间版本+getAndSet(阻塞读）

redis单线程的原因：单线程避免了上下文的频繁切换所带来的时间开销；redis采用IO多路复用模型，提高单线程的处理能力。

### 9）分布式消息队列

**消息队列中间件**是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。 目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。

最主要得应用场景：**解耦、异步、削峰、通讯**

消息队列系统，一般都包含**3个角色：队列服务端，队列的生产者，队列的消费者**。
 　消息队列系统类似于这个场景：有一条信息传送带不停地运转。在传送带的起点，工人a不断地把信息放在一个盒子，把盒子放到传送带上，盒子被传送带传送到终点。在终点上，工人b把盒子上的信息取出来，进行处理。
 　在上面的场景中，不停运转的传送带就是队列服务端，在传送带起点不断放盒子的工人a就是队列的生产者，在传送带终点不断取盒子的工人b就是队列的消费者。
 　消息队列的服务端，现在有大量的开源的应用，例如RabbitMQ ，ZeroMQ ，redis等。
 　队列的生产者和服务者，是针对消息队列服务端开发的客户端，例如，RabbitMQ就有针对java，php等语言开发的客户端。